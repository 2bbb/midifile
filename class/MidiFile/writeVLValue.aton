@@BEGIN:	FunctionDocumentation
@CLASSNAME:	MidiFile
@METHOD:	writeVLValue
@ACCESS:	private
@RETURN:	void
@PARAMETERS:	long value, vector<uchar>& data
@FILE:		MidiFile.cpp
@LINES:		1724-1881
@SEEALSO:	
@SHORTDESC:	Convert an integer int a list of VLV bytes.
@LONGDESC:	Convert an integer int a list of VLV bytes.

@@BEGIN: EXAMPLE
@DESCRIPTION:
@CODE:
@OUTPUT:
@@END:	EXAMPLE

@SRCCODE:

//////////////////////////////
//
// MidiFile::writeVLValue -- write a number to the midifile
//    as a variable length value which segments a file into 7-bit
//    values.  Maximum size of aValue is 0x7fffffff
//

void MidiFile::writeVLValue(long aValue, vector&lt;uchar&gt;&amp; outdata) {
   uchar bytes[5] = {0};
   bytes[0] = (uchar)(((ulong)aValue &gt;&gt; 28) &amp; 0x7f);  // most significant 5 bits
   bytes[1] = (uchar)(((ulong)aValue &gt;&gt; 21) &amp; 0x7f);  // next largest 7 bits
   bytes[2] = (uchar)(((ulong)aValue &gt;&gt; 14) &amp; 0x7f);
   bytes[3] = (uchar)(((ulong)aValue &gt;&gt; 7)  &amp; 0x7f);
   bytes[4] = (uchar)(((ulong)aValue)       &amp; 0x7f);  // least significant 7 bits

   int start = 0;
   while (start&lt;5 &amp;&amp; bytes[start] == 0)  start++;

   for (int i=start; i&lt;4; i++) {
      bytes[i] = bytes[i] | 0x80;
      outdata.push_back(bytes[i]);
   }
   outdata.push_back(bytes[4]);
}



///////////////////////////////////////////////////////////////////////////
//
// external functions
//


//////////////////////////////
//
// eventcompare -- for sorting the tracks
//

int eventcompare(const void* a, const void* b) {
   MidiEvent&amp; aevent = **((MidiEvent**)a);
   MidiEvent&amp; bevent = **((MidiEvent**)b);

   if (aevent.tick &gt; bevent.tick) {
      return 1;
   } else if (aevent.tick &lt; bevent.tick) {
      return -1;
   } else if (aevent[0] == 0xff &amp;&amp; bevent[0] != 0xff) {
      return 1;
   } else if (bevent[0] == 0xff &amp;&amp; aevent[0] != 0xff) {
      return -1;
   } else if (bevent[0] == 0xff &amp;&amp; bevent[1] == 0x2f) {
      return -1;
   } else if (aevent[0] == 0xff &amp;&amp; aevent[1] == 0x2f) {
      return 1;
   } else if (((aevent[0] &amp; 0xf0) == 0xe0) &amp;&amp;
              ((bevent[0] &amp; 0xf0) == 0x90)) {
      // pitch bend placed before note on messages
      return -1;
   } else if (((aevent[0] &amp; 0xf0) == 0x90) &amp;&amp;
              ((bevent[0] &amp; 0xf0) == 0xe0)) {
      // pitch bend placed before note on messages
      return +1;
   } else if (((aevent[0] &amp; 0xf0) == 0x90) &amp;&amp;
              ((bevent[0] &amp; 0xf0) == 0x80)) {
      return 1;
   } else if (((aevent[0] &amp; 0xf0) == 0x80) &amp;&amp;
              ((bevent[0] &amp; 0xf0) == 0x90)) {
      return -1;
   } else {
      return 0;
   }
}



//////////////////////////////
//
// operator&lt;&lt; -- for printing an ASCII version of the MIDI file
//

ostream&amp; operator&lt;&lt;(ostream&amp; out, MidiFile&amp; aMidiFile) {
   int i, j, k;
   out &lt;&lt; "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n";
   out &lt;&lt; "Number of Tracks: " &lt;&lt; aMidiFile.getTrackCount() &lt;&lt; "\n";
   out &lt;&lt; "Time method: " &lt;&lt; aMidiFile.getTimeState();
   if (aMidiFile.getTimeState() == TIME_STATE_DELTA) {
      out &lt;&lt; " (Delta timing)";
   } else if (aMidiFile.getTimeState() == TIME_STATE_ABSOLUTE) {
      out &lt;&lt; " (Absolute timing)";
   } else {
      out &lt;&lt; " (unknown method)";
   }
   out &lt;&lt; "\n";

   out &lt;&lt; "Divisions per Quarter Note: " &lt;&lt; dec
       &lt;&lt; aMidiFile.getTicksPerQuarterNote() &lt;&lt; "\n";
   for (i=0; i&lt;aMidiFile.getNumTracks(); i++) {
      out &lt;&lt; "\nTrack " &lt;&lt; i
          &lt;&lt; "   +++++++++++++++++++++++++++++++++++++++++++++++++++\n\n";
      for (j=0; j&lt;aMidiFile.getNumEvents(i); j++) {
         out &lt;&lt; dec &lt;&lt; aMidiFile.getEvent(i, j).tick &lt;&lt; "\t"
             &lt;&lt; "0x" &lt;&lt; hex &lt;&lt; (int)aMidiFile.getEvent(i, j)[0] &lt;&lt; " ";
         if (aMidiFile.getEvent(i, j)[0] == 0xff) {

            if (aMidiFile.getEvent(i, j)[1] == 0x01) {
               out &lt;&lt; "TEXT [";
               for (k=3; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; (char)aMidiFile.getEvent(i, j)[k];
               }
               out &lt;&lt; "]";

            } else if (aMidiFile.getEvent(i, j)[1] == 0x02) {
               out &lt;&lt; "COPY [";
               for (k=3; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; (char)aMidiFile.getEvent(i, j)[k];
               }
               out &lt;&lt; "]";

            } else if (aMidiFile.getEvent(i, j)[1] == 0x03) {
               out &lt;&lt; "TRACK [";
               for (k=3; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; (char)aMidiFile.getEvent(i, j)[k];
               }
               out &lt;&lt; "]";

            } else if (aMidiFile.getEvent(i, j)[1] == 0x04) {
               out &lt;&lt; "INSTR [";
               for (k=3; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; (char)aMidiFile.getEvent(i, j)[k];
               }
               out &lt;&lt; "]";

            } else if (aMidiFile.getEvent(i, j)[1] == 0x05) {
               out &lt;&lt; "LYRIC [";
               for (k=3; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; (char)aMidiFile.getEvent(i, j)[k];
               }
               out &lt;&lt; "]";

            } else {
               for (k=1; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
                  out &lt;&lt; dec &lt;&lt; (int)aMidiFile.getEvent(i, j)[k] &lt;&lt; " ";
               }
            }

         } else {
            for (k=1; k&lt;(int)aMidiFile.getEvent(i, j).size(); k++) {
               out &lt;&lt; dec &lt;&lt; (int)aMidiFile.getEvent(i, j)[k] &lt;&lt; " ";
            }
         }
         out &lt;&lt; "\n";
      }
   }
   out &lt;&lt; "+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n";
   return out;
}

@@END:	FunctionDocumentation



