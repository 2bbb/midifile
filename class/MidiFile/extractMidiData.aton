@@BEGIN:	FunctionDocumentation
@CLASSNAME:	MidiFile
@METHOD:	extractMidiData
@ACCESS:	private
@RETURN:	int
@PARAMETERS:	istream& input, vector<uchar>& array, uchar& runningCommand
@FILE:		MidiFile.cpp
@LINES:		1577-1669
@SEEALSO:	
@SHORTDESC:	Extract a MIDI message from the input stream.
@LONGDESC:	Extract a MIDI message from the input stream.  If the
		MIDI message is in running mode, use the previous
		MIDI command; otherwise store the current command byte
		in case the next message is in running mode.  Returns 0
		if there was a problem extracting the MIDI data, otherwise
		returns 1.

@@BEGIN: EXAMPLE
@DESCRIPTION:
@CODE:
@OUTPUT:
@@END:	EXAMPLE

@SRCCODE:

//////////////////////////////
//
// MidiFile::extractMidiData -- Extract MIDI data from input
//    stream.  Return value is 0 if failure; otherwise, returns 1.
//

int MidiFile::extractMidiData(istream&amp; input, vector&lt;uchar&gt;&amp; array,
   uchar&amp; runningCommand) {

   int character;
   uchar byte;
   array.clear();
   int runningQ;

   character = input.get();
   if (character == EOF) {
      cerr &lt;&lt; "Error: unexpected end of file." &lt;&lt; endl;
      return 0;
   } else {
      byte = (uchar)character;
   }

   if (byte &lt; 0x80) {
      runningQ = 1;
      if (runningCommand == 0) {
         cout &lt;&lt; "Error: running command with no previous command" &lt;&lt; endl;
         return 0;
      }
   } else {
      runningCommand = byte;
      runningQ = 0;
   }

   array.push_back(runningCommand);
   if (runningQ) {
      array.push_back(byte);
   }

   uchar metai;
   switch (runningCommand &amp; 0xf0) {
      case 0x80:        // note off (2 more bytes)
      case 0x90:        // note on (2 more bytes)
      case 0xA0:        // aftertouch (2 more bytes)
      case 0xB0:        // cont. controller (2 more bytes)
      case 0xE0:        // pitch wheel (2 more bytes)
         byte = MidiFile::readByte(input);
         array.push_back(byte);
         if (!runningQ) {
            byte = MidiFile::readByte(input);
            array.push_back(byte);
         }
         break;
      case 0xC0:        // patch change (1 more byte)
      case 0xD0:        // channel pressure (1 more byte)
         if (!runningQ) {
            byte = MidiFile::readByte(input);
            array.push_back(byte);
         }
         break;
      case 0xF0:
         switch (runningCommand) {
            case 0xff:                 // meta event
               {
               if (!runningQ) {
                  byte = MidiFile::readByte(input); // meta type
               array.push_back(byte);
               }
               metai = MidiFile::readByte(input); // meta type
               array.push_back(metai);
               for (uchar j=0; j&lt;metai; j++) {
                  byte = MidiFile::readByte(input); // meta type
                  array.push_back(byte);
               }
               }
               break;
            case 0xf0:                // sysex
               // read until you find a 0xf7 character
               byte = 0;
               while (byte != 0xf7 &amp;&amp; !input.eof()) {
                  byte = MidiFile::readByte(input); // meta data
               }
               break;
         }
         break;
      default:
         cout &lt;&lt; "Error reading midifile" &lt;&lt; endl;
         cout &lt;&lt; "Command byte was " &lt;&lt; (int)runningCommand &lt;&lt; endl;
         return 0;
   }
   return 1;
}

@@END:	FunctionDocumentation



